Говорят, что программист 1с нужен на предприятии лишь затем, чтобы осуществлять проводки "задним числом" и править базу в обход его (1с) родных алгоритмов (нестандартные, но востребованные, операции и суровая реальность этой страны), со всем остальным тупо справится админ, да и с этим тоже, но ленится/брезгует/не хочет брать на себя чужой геморой. Грубо говоря - живой компонент системы (обезьяна). Иначе просто не объяснишь их востребованность там, где готовых решений больше, чем снега зимой. Кстати, большинство из них и работают за зарплату, на которую реально можно купить только миску супа и оплатить коммунальные услуги на одного человека, хорошо хоть работенка у них не пыльная особо и можно взять что-то по совместительству (например, мыть полы в офисе).
Плюсоебство - это как православие. Когда протестантизм завещает работать над собой и создавать блага, славя величие Господа, православие требует от последователя искупления греха, посредством непрерывного страдания, как страдал Иисус неся свой крест. Стрелять себе в ногу и нажираясь потом водкой, позерски ноя о тяжестях нищебродской жизни -- что может быть лучше для православного плюсоеба?
Вообще, эмель сдох. Никакого развития нет и не планируется. Тот же Лерой прямо писал в конфочку, что да, ГЦ окамла сосет, но ему похуй, ничего делаться не будет. А раньше раньше развитие было разным в разных реализациях, т.е. приличная оптимизация в Млтон, свежие языковые фишечки в нью-джерси или москоу, человеческое лицо в элис, в окамле - традиционнно сосание хуйцов бесплатно. Флагманской реализации так и не появилось, язык распался на диалекты. 
На шарпе нет ни нормального IoC, ни билд-фреймворка, ни нормальных webMVC, ни ORM. Только ебаный .НЕТ ФРЕЙМВОРК и кусок бинарного говна - silverlight, вообще охуеть. Это не бро. Джава же это отличный язык для сложных и надежных систем, для embeeded разработки, для веба, даже для реалтайма. Джава отлично работает на нормальных операционных ситемах - posix, да что там говорить она работает на любой ОС и платформе - даже на симкартах и контроллерах. У нее есть куча охуенных спецификаций на все случаи жизни. Большой и активный коммюнити, который всегда поможет. Большинство кода на джаве - опенсорсный, поэтому это отличный язык для обучения джуниоров - ведь поняв как написан код в крупных и серьезных проектах человек учится и его уровень как программиста растет. На джаве есть куча охуенных фрейворков - play, akka, spring,hibernate,maven,harmony,tapestry. На JVM есть множество языков на любой вкус - Scala, Ruby, Python, Groovy, JavaScript, Clojure и вс
На похапэ можно писать довольно быстрый код. Конечно, не такой резкий, как заточенный под конкретную задачу инстанс nodejs или, не дай бог, что-нибудь для веб на няшной с ассемблерными вставками. Можно банально придерживаться паттерна mvc и не погрязнуть в паутине спагетти-скриптов с сотнями инклюдов. Код будет хотя бы структурирован и изолирован локальными кучками говнеца. Это идеальное состояние, если большую часть рабочего времени вы добавляете в общую свалку новые, независимые друг от друга конвертики с тухлятиной.
Ебать, саентач, ты меня расстраиваешь. Уже в /pr/ на плюсы батхерты прекратились, а тут все то же самое. На С++ батхертят неосиляторы и задроты с ЛОРа. С++ - универсальный язык, а не только промышленная копипаста, его даже ЦЕРНе как очень быстрый скрипт используют для обработки гигабайт статистики со всяких коллайдеров, и такие же эффективные альтеративы этому намного менее удобные. Машина должна и будет служить людям, она не шлюха, чтобы люди исполняли её прихоти. Отсюда байтобляди (а так же сочувствующие им императивные пидорасы, надрачивающие на показатели System.currentTimeMillis() - start) - пиздолисы, которые опускаются до полного говноедства, лишь бы ублажить её регистры и микросхемы. Альфапрограммисты, как и положено альфам, если машина не выполняет положенных ей задач и требует пресмыкаться перед ней и ублажать её байтами, просто берут и за патчкорды, ебашат с вертушки по передней панели и списывают машину на мороз, купив взамен ту, которая не будет выёбываться и выполнит код в сроки и без выебонов, будь там хоть 1000% неоптимизированного оверхеда. И настоящего программиста не волнуют вопросы выдрачивания и быстродействия - он решает важную задачу из предметной области гораздо более сложной, чем низкоуровневое дрочево, и отвлекаться на всякую подзалупную хуету вроде осоьбеннойстей какой-то там архитектуры ему некомильфо.
У меня есть коллега, который презирает уровни доступа С++. Он работает на низком уровне, использует С++, как С с классами. Драйвера, софт для embedded и т.п. Когда я ему начинаю говорить про типобезопасность, инкапсуляцию, он говорит, что возьмет и получит нужные данные по смещению. Ну и что ему возразишь? Ничего. Он прав. Если кто-то захочет - он сделает. Даже в мейнстримовых песочницах можно. Вопрос цены только.
Указывать сиблядям на проблемы языка бесполезно. Кроме сишки сиблядь нихуя не знает и не умеет, а на любое обвинение у сибляди есть универсальный ответ - "криворукость". Этим сиблядь как-бы намекает, что что все вокруг криворуки - т.е. сотрудники микрософта и интеля, пишущие кривые драйвера и библиотеки, прыщебляди, пишущие дырявое ведро своей системы вот уже не первый десяток лет, просто другие сибляди из соседнего подвала полусвовковой шаражки, в которой сиблядь работает. А вот сама сиблядь - сука граф Шарль Ожье де Бац де Кастельмор д’Артаньян среди педерастов, владеющий техникой левитации, предсказания будущего и написания небыдлокода на сишке. К сожалению, простым смертным едва ли не удастся увидеть творения сенсея, так и будут они работать с глючным говном криворуких интелевских и микросовтовских инжеренов, внезапно падающим от какого-нибудь buffer overflow, несмотря на зиллионы человекочасов, проёбанных на его тестирование и отладку.
C++ Не может в управление памятью Не может в LALR грамматику Как следствие, не может в человеческий синтаксис Не может в денотационную семантику Не может в настоящие макросы (с темплейтами отсос - не могут в квазицитирование) Следствие - не может в человеческий полиморфизм (не говоря про higher-order), только убогое кодовысерание. Не может в referential transparency Linear typing ... и остальные миллиарды отсосов
ПРИШЛО ВРЕМЯ ОСВОБОДИТЬ ПАМЯТЬ ПАМЯТЬ САМА НЕ ОСВОБОДИТСЯ ОСВОБОДИ ЕЁ, ОСВОБОДИ ЕЁ ЕЩЕ РАЗ ЗАЧЕМ МНЕ НУЖЕН ХАЧКЕЛЬ, У МЕНЯ НЕТ ВРЕМЕНИ ЧТОБЫ ЕБАТЬСЯ С НИМ ЛУЧШЕ ЕЩЕ РАЗ ОСВОБОДИТЬ ПАМЯТЬ Я ОСВОБОЖДАЮ ПАМЯТЬ ПО 3 РАЗА В ДЕНЬ КАЖДОЕ ОСВОБОЖДЕНИЕ ЗАНИМАЕТ ДВАДЦАТЬ НАНОСЕКУНД Я ЖИВУ АКТИВНОЙ И ПОЛНОЦЕННОЙ ЖИЗНЬЮ Я УСПЕШЕН И ПОЭТОМУ ЦЕЛЫЙ ДЕНЬ ВЫДЕЛЯЮ ПАМЯТЬ А ПОСЛЕ ЭТОГО ОСВОБОЖДАЮ ЕЁ ТУПЫЕ ХАЧКЕБЛЯДКИ ОДЕРЖИМЫ МОНАДАМИ А Я СВОБОДНЫЙ ОТ ЗАДРОТСТВА ЧЕЛОВЕК TEMPLATE <CLASS BAZ> BAR * FOO<BAZ>::DOWORK() int s=((12<<5)&(2^(21-(4|4)*2)^1024))==0?1:0 ЛУЧШЕ Я ВЫДЕЛЮ ЕЩЕ РАЗ ПАМЯТЬ И ЗАБУДУ ОСВОБОДИТЬ ЕЁ, СТАБИЛЬНОСТЬ НЕ НУЖНА Я НЕ ОСВОБОЖДАЛ ПАМЯТЬ НЕДЕЛЮ ПОЙДУ ОСВОБОЖУ  В C++ ВСЕ ПРОСТО И ПОНЯТНО SEGMENTATION FAULT. ЭТО ЖЕ ОЧЕВИДНО КАК ЕЕ РЕШИТЬ ПРИШЛО ВРЕМЯ ОСВОБОДИТЬ ПАМЯТЬ КОКОКОКОКОКОКО КВИКСОРТ КОНКАТЕНАЦИЯ ЗА O(1) INLINE ASSEMBLER КОКОКОКОКОКОКО
oSQL исторически появился раньше SQL-а, собственно весь ынтырпрайз до 70-х им в жопу и долбился. Потом британский ученый изобрёл теорию РБД, появление которой привело к немедленному выметанию всего этого ёбаного хаоса с рынка, стандартизации и тотальному овладиванию SQL-а в рекордно короткие сроки. Побочным эффектом стало то, что всякое быдло начало пихать SQL туда, где он не очень-то и нужен, и очень, блядь, страдать, от того, что их гостевухи стали долго загружаться. 
Я за макинтошем. Ты за белым макбуком, и я за белым макбуком. А потом на конференцию. А потом салют... в нашу честь. Салют в нашу честь. Сначала на конференцию, а потом в коворкинг. Кодить будем. Пиво. Салют. В мою честь салют. Я тимлид, и ты — за белым макбуком. Ты меня слышишь? Посмотри, какой у меня код! Посмотри, какие у него отступы! Я его еще никому не показывал. Только тебе покажу. Посмотри! Это мой класс. Специально написал! Инициализируй, не бойся! Интерфейс? Я его поменяю! Вот он, интерфейс. Вот! Настоящий! Видишь? Тимлид. Я тимлид. Я его на гитхаб отправлю. Это мой код. Самый чистый. DRY. Что ты выгорел? Вот пойдем в коворинг, пива выпьем — и выгорать не будешь. Я, в слаке, за белым макбуком, командую репозиторием! Я тимлид! Я командую репозиторием! У меня звезды на гитхабе! За белым макбуком! Я тимлид! Я командую репозиторием!
Просто веб-макачье в очередной раз ткнули носом в MVC и паттерн observable, заодно пустив на этом волну пиара. До этого макачье не могло в простейший pubsub на 10 строчек и вместо нормального кода хуярило полнейшее спагетти из вкусной копи-пасты. А все почему? Потому что веб-макака — не программист, а отброс, которого надо тыкать носом, пока оно не научится хоть что-то делать. Но себя макаки считают ниибаться авангардом всея технологий, поэтому ткнуть им в «мудоебы, 30 лет назад придумали Smalltalk, смотрите, блядь, как вот это говно делается просто и по-уму» нельзя (всяких штуденческих диссеров с «мы припрем в веб-браузер концепт actor'ов» было и 5 и 7 лет назад — все до единого забыты нахуй), им надо КУКАРЕКУ ПРОРЫВ В ВЕБ-РАЗРАБОТКЕ НОВЫЕ ТЕХНОЛОГИИ КОКОКО ИННОВАЦИОННЫЙ ДИЗАЙН ИСПОЛЬЗУЕТСЯ В ЛИДИРУЮЩИХ СТАРТАПАХ ДАСТИН МОСКОВИЦ ОДОБРЯЕТ КУДАХ-ТАХ-ТАХ NODEJS WEBSOCKETS HTML5 MOBILE RESPONSIBLE WEB DESIGN HATEOAS MONGODB. Тогда они обращают внимание и начинают кое-как пользоваться.
Ты знаешь, это очень обидно, когда какой-то уебок подходит, и говорит "ты же программист, установи мне программу". Это не работа программиста, говно.
Завтра ищешь в интернете книжку Dive into python. Похуй если ничего не поймешь. Затем идешь на python.org и изучаешь стандартную библиотеку от корки до корки. Потом зубришь, именно, сука, вызубриваешь конвенцию по написанию питоньего кода - PEP8, чтобы от зубов отскакивало. Когда напишешь свою первую имиджборду, по пути изучив верстку на html+css, скачиваешь и изучаешь любой питоний асинхронный вебсервер, рекомендую Tornado или Gevent. Как переделаешь имиджборду, чтобы выдавала по крайней мере 5 тысяч запросов в секунду, можешь идти дальше - тебя ждет увлекательный мир хайлоада. Apache Hadoop, сверхбыстрые асинхронные key-value хранилища, MapReduce. Отсос хиккующих выблядков / просто неудачников типа рейфага или сисярп/джава-хуесосов, которые сосут хуй по жизни не заставит себя ждать и уже через пол года ты будешь получать такие суммы, что любая баба будет течь при одном упоминании твоей зарплаты.
Завтра идешь на Тверскую и берешь у первого попавшегося мужчины в рот. похуй если не понравится. затем разрабатываешь именно РАЗРАБАТЫВАЕШЬ свое очко, пока туда не начнет влезать сгущенка, по пути поучаствовав на закрытой гей оргии в пассивной роли. потом покупаешь себе костюм (рекомендую черный латекс или пожарник) и становишься шалавой. тебя ждет увлекательный мир гей-шлюхи. негритянские хуи, сверхвонючий копро-секс, супер потные грязные яйца. отсос тебе обеспечен и уже через полгода ты будешь принимать такие дозы спермы что любой СПЕРМОВОР будет лохом по сравнению с тобой.
Хеллоуворлдщик (хелловорлдщик) — поциент, думающий, что он круче Д`Артаньяна и пишет программы лучше, чем все другие. При этом, в отличие от быдлокодера, образец и не претендует на написание хоть чего-либо осмысленного.
Быдлокодер (aka погромист, горе-программист, индус; англ. Code Monkey) — это человек, который считает рекурсию мемом башорга и не знает основных алгоритмов и тонкостей языка, на котором пишет. Поэтому быдлокодер использует неочевидные и абсурдные решения.
«Умение разбираться в чужом коде» — строка-детектор, которая содержится чуть более, чем во всех вакансиях на должность программиста и смежные должности. Чаще всего акцент на этой фразе делается для вакансий разработчика на C++ и PHP, где «чужой» не только код.
int i = 0; ++i + ++i; мудила, посчитаешь, пиши
Слушай сюда програмистишка хуесошика ты давай тут ебало не открывай, сидишь в своей зоне комфорта на питоне дроченом ну и сиди, а сейчас жопу подставил мой пакет питона уже на коммите висит сейчас будем пушить ... Что значит не готов ещё к пуллу, давай быстро собрал свою дев ветку и принял изменения щенок
Примечательно, что фаза Луны влияет на разные сущности по-разному. Наиболее подвержены этому явлению программы, написанные на: С++, С — фаза Луны начинает действовать на вашу программу, как только вы зафейлите указатель. Delphi, PHP — исключительно в силу талантливости программистов, пишущих на этих языках. Хотя талантливый программист может написать датчик фазы Луны на любом, даже самом лунно-независимом языке. Кроме того, фаза Луны™ сильно, очень сильно мешает горе-админам.  А в видеоиграх фаза Луны может так или иначе влиять на геймплей:  Final Fantasy 14 — фаза игровой Луны таки официально влияет на крафт. Minecraft — а фаза игровой Луны тут влияет на спавнрейт слизней в болотах. Причем здесь луна и слизни? Слизни сами по себе задумывались как редкие мобы, а луна неплохо влияла на уменьшение вероятности встречи с потенциальными слизнями. Superbrothers: Sword & Sworcery — фаза реальной (не игровой!) луны влияет на геймплей. Серьезно. Nethack — фаза реальной луны тоже влияет на игру, например, в полнолуние у игрока увеличивается удача, а оборотни появляются всегда в облике животного.
«Си» позволяет очень просто выстрелить себе в ногу. На «Си++» сделать это сложнее, но, когда вы это делаете, отрывает всю ногу.
C++: Вы случайно создаете дюжину копий объекта «вы» и всем им простреливаете ногу. Срочная медицинская помощь оказывается невозможной, так как вы не можете разобраться, где настоящие копии, а где — те, что только указывают на них и говорят: «А вот он я!»
Java: После импорта java.awt.right.foot.* и java.awt.gun.right.hand.* и написания классов и методов, необходимых для этих классов, вы забываете, что вы, чёрт возьми, хотели сделать.
C#: Вы пытаетесь прострелить себе ногу, но осознаете, что для этого вам нужен 5 диск MSDN с хелпом и Visual Studio .NET… и в любом случае решетка C# не дает прострелить вам ногу, так как тот код, который вы пишете для Mono, Microsoft уже запатентовала.
SQL: BEGIN; INSERT INTO нога (ступня) SELECT патроны AS пуля FROM пистолет WHERE курок = 'СПУЩЕН'; COMMIT;
Delphi: Вы залезаете на форумы и слезно умоляете дать вам компонент для прострела ноги. После компиляции нога опухает, и её масса превышает массу тела.
JavaScript: Вы прочитали 3 книги, изучили 10 наглядных примеров, разработали потрясающий интерфейс и теперь, кажется, готовы к тому, чтобы выстрелить себе в ногу. Потом в процессе стрельбы обнаруживаете, что пули имеют радиус действия, равный длине ствола, и испаряются прямо на выходе.
CSS: Переложив пистолет в левую руку, вы понимаете, что держите его не за рукоять, а за дуло. Вы переворачиваете его и понимаете, что теперь он смотрит стволом в сторону вашей головы. Ещё немного изменив стили, вы понимаете, что всё теперь как надо, но только он находится на 15 пикселей левее вашей руки.
node.JS: Вы начинаете асинхронно стрелять из асинхронных рук в асинхронные ноги, асинхронно не попадаете и запутываетесь в этой каше.
Objective-C/Cocoa: Вы строите стильный интерфейс, соответствующий всем канонам Apple. Вы два раза копируете и ногу, и пистолет, чтобы они работали под архитектурами как Intel, так и PowerPC. Вы удостоверяетесь, что пистолет можно зарядить с помощью всего одного клика мышкой. Когда всё уже готово, вы понимаете, что при нажатии на спуск пистолет не стреляет. Перебрав весь код вашей программы, вы обнаруживаете, что забыли указать, что графический объект спускового крючка — и есть спусковой крючок.
Ruby: Ваша нога готова к выстрелу примерно через пять минут, но вы не можете найти места, где можно стрелять.
PHP: Вы стреляете себе в ногу из пистолета, сделанного из частей 300 других пистолетов.
ASP.NET: Вы находите пистолет, но он разваливается. Вы его собираете, но он снова разваливается. Вы пытаетесь использовать платформу .GUN, но она разваливается. Вы режете себе ногу.
Perl: Вы стреляете себе в ногу, и никто не может понять, как вы сделали это. Через шесть месяцев не можете и вы.
Erlang: Вы описываете поведение стреляющего устройства, создаете десяток устройств от арбалета до КПВТ на его основе, одновременно стреляющее из тысячи разных мест и позволяющее горячую замену пуль прямо во время стрельбы. После поражения ноги она умирает и каскадно уносит с собой все тело. Супервизор отращивает новое тело с непораженной ногой. Вы офигеваете, что после такого залпа нога все еще целая, а также от блевотного Tk-интерфейса appmon, через который просматриваете состояние ноги.
FORTRAN: Итеративно вы простреливаете каждый палец ноги, а когда пальцы заканчиваются, загружаете следующую ногу и продолжаете. Когда пули заканчиваются, а пальцы давно потеряли всякое сходство с пальцами, вы все равно продолжаете попытки прострелить себе ноги, потому что не имеете возможности обрабатывать исключения.
Modula2: Поняв, что с помощью этого языка ничего толком сделать нельзя, вы простреливаете себе голову.
Pascal: Компилятор не позволит вам прострелить себе ногу.
Rust: Вы покупаете пистолет, который может стрелять только при ночной сборке. Вы пытаетесь выстрелить в ногу, однако выясняется, что нога заимствована и неизменяема, а пуля не может быть перемещена. В конечном счёте вы игнорируете все проверки, после чего пистолет взрывается, а ноги остаются атрофированными по сравнению с торсом из-за пропуска дня ног в спортзале.
Ada: После тщательной сборки пакета «нога», вы пытаетесь одновременно зарядить пистолет, нажать курок, завопить и выстрелить себе в ногу. В ходе попыток обнаруживается, однако, что вас постигла неудача, так как ваша нога оказалась неверного типа.
Кобол: Наводите ПИСТОЛЕТ COLT 45 на НОГА.СТОПА, ТОГДА помещаете РУКА.КИСТЬ.ПАЛЕЦ на ПИСТОЛЕТ.КРЮЧОК и ПОЖАЛУЙСТА, НАЖИМАЕТЕ. ТОГДА возвращаете ПИСТОЛЕТ в КОБУРУ. ПОЖАЛУЙСТА, ПРОВЕРЬТЕ, нуждаются ли шнурки в повторном связывании.
LISP: Вы простреливаете себе отросток, который держит пистолет, с помощью которого вы простреливаете себе отросток, который держит пистолет, с помощью которого вы простреливаете себе отросток, который держит пистолет, с помощью которого вы простреливаете себе отросток, который держит пистолет, с помощью которого вы простреливаете себе отросток, который…
Forth: Нога себе прострелить вы.
Prolog: Вы сообщаете вашей программе, что хотите иметь простреленную ногу. Программа разрабатывает способ этого достичь, но синтаксис языка не позволяет объяснить этот способ вам.
Basic: Вы простреливаете себе ногу из водяного пистолета. В расширенных реализациях языка продолжайте, пока вся нижняя часть тела не промокнет. В реализациях с возможностью делать вставки из ассемблера вы используете ранее созданные типы и уже в ассемблерной части простреливаете ногу дробовиком.
Visual Basic: Вы прострелите себе ногу. Однако в процессе реализации вы получите столько удовольствия, что подобные мелочи вас не озаботят.
Visual BASIC.NET: Вы тратите целое состояние на мощнейший, самоочищающийся, самонаводящийся, автоматический пистолет с бесконечным боезапасом и только тогда понимаете, что спуск курка занимает около года (источник).
HyperTalk: Поместите первую пулю пистолета в ступню левой ноги вас. Сообщите результат.
Smalltalk: Мой нога стреляй себя.
Motif: Вы затрачиваете несколько дней на построение UIL — описания вашей ноги, пули, её траектории и замысловатой резьбы по слоновой кости на рукоятке пистолета. Когда вы наконец-то управились и готовы нажать на курок, затвор заклинивает.
APL: Вы простреливаете себе ногу, затем тратите весь день на то, чтобы представить себе, как это сделать с меньшим количеством символов.
Снобол: Если вам удастся, прострелите себе левую ногу. Если не удастся, то прострелите себе правую ногу.